from django.utils import timezone
from rest_framework import viewsets, status
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework_simplejwt.tokens import RefreshToken
import hashlib
import os

from .models import Person, UserAccount, PersonRoleMapping
from .serializers import PersonSerializer, LoginSerializer, UserProfileSerializer


def hash_password(password):
    """Hash password using SHA-512 to match existing database format"""
    return hashlib.sha512(password.encode()).hexdigest()


class LoginView(APIView):
    """Handle user authentication"""
    permission_classes = [AllowAny]

    def post(self, request):
        serializer = LoginSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        username = serializer.validated_data['username']
        password = serializer.validated_data['password']

        try:
            user = UserAccount.objects.select_related('person').get(username=username)
        except UserAccount.DoesNotExist:
            return Response(
                {'error': 'Invalid credentials'},
                status=status.HTTP_401_UNAUTHORIZED
            )

        # Check password (assuming SHA-512 hash in database)
        password_hash = hash_password(password)
        if user.password_hash != password_hash:
            # Increment failed login attempts
            user.failed_login_attempts += 1
            user.save(update_fields=['failed_login_attempts'])
            return Response(
                {'error': 'Invalid credentials'},
                status=status.HTTP_401_UNAUTHORIZED
            )

        # Check if account is active
        if user.account_status != 'active':
            return Response(
                {'error': 'Account is not active'},
                status=status.HTTP_403_FORBIDDEN
            )

        # Update last login
        user.last_login = timezone.now()
        user.failed_login_attempts = 0
        user.save(update_fields=['last_login', 'failed_login_attempts'])

        # Generate JWT tokens
        refresh = RefreshToken()
        refresh['user_id'] = user.user_id
        refresh['username'] = user.username
        refresh['is_superuser'] = user.is_superuser()

        return Response({
            'access': str(refresh.access_token),
            'refresh': str(refresh),
            'user': UserProfileSerializer(user).data
        })


class PersonViewSet(viewsets.ModelViewSet):
    """CRUD operations for Person model"""
    queryset = Person.objects.all().order_by('person_id')
    serializer_class = PersonSerializer
    permission_classes = [AllowAny] # Temporarily disable for debugging

    def get_queryset(self):
        """Optionally filter by is_approved status"""
        queryset = Person.objects.all().order_by('person_id')
        is_approved = self.request.query_params.get('is_approved', None)
        if is_approved is not None:
            queryset = queryset.filter(is_approved=is_approved.lower() == 'true')
        return queryset

    def create(self, request, *args, **kwargs):
        """Create a new person"""
        log_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'api_debug.log')
        with open(log_path, 'a') as f:
            f.write(f"\n--- Create Person Request at {timezone.now()} ---\n")
            f.write(f"Data: {request.data}\n")
            f.write(f"Headers: {request.headers}\n")
            
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)
            
            # Get the next person_id (since it's not auto-generated by PostgreSQL)
            last_person = Person.objects.order_by('-person_id').first()
            next_id = (last_person.person_id + 1) if last_person else 1
            
            with open(log_path, 'a') as f:
                f.write(f"Validated Data: {serializer.validated_data}\n")
                f.write(f"Calculated next_id: {next_id}\n")

            # Create person with explicit ID
            person = Person.objects.create(
                person_id=next_id,
                **serializer.validated_data
            )
            
            with open(log_path, 'a') as f:
                f.write(f"Successfully created person ID: {person.person_id}\n")

            return Response(
                PersonSerializer(person).data,
                status=status.HTTP_201_CREATED
            )
        except Exception as e:
            with open(log_path, 'a') as f:
                f.write(f"ERROR creating person: {str(e)}\n")
            raise
